package authenticator

import (
	"path/filepath"

	"github.com/matheusqueirozzabin/exception"
	"github.com/matheusqueirozzabin/sqlite"
)

type Authenticator struct {
	tokenDuration          int64
	singleUseTokenDuration int64

	maxFailAttemptsPerMinute  int
	maxFailAttemptsPer12Hours int

	secret []byte
	issuer string

	database *sqlite.DB
}

type jwt struct {
	Permissions string `json:"perm"`            // String generated by bitpermission
	ExpireAt    int64  `json:"exp"`             // Unix Timestamp from token expire
	IssuedAt    int64  `json:"iat"`             // Unix Timestamp from token emission
	Issuer      string `json:"iss"`             // URL from host
	Audience    string `json:"aud"`             // For single use tokens, represents the route to be used, for standard token, the service name
	Subject     int64  `json:"sub"`             // Generally user ID
	Route       string `json:"route,omitempty"` // Route stores route to be use on single use token
	ID          int64  `json:"jti,omitempty"`   // Token generated by API for single use tokens
}

func New(path string, issuer string, secret []byte, tokenDuration int64, singleUseTokenDuration int64, maxAttemptsMinute int, maxAttempts12Hours int) (newAuthenticator *Authenticator, err error) {
	defer exception.Catch(&err, func(_ error) {
		newAuthenticator = nil
	})

	newAuthenticator = &Authenticator{
		secret: secret,
		issuer: issuer,

		tokenDuration:          tokenDuration,
		singleUseTokenDuration: singleUseTokenDuration,

		maxFailAttemptsPerMinute:  maxAttemptsMinute,
		maxFailAttemptsPer12Hours: maxAttempts12Hours,

		database: nil,
	}

	if newAuthenticator.database, err = sqlite.New(
		filepath.Join(path, fileName),
		maxOpenConnections,
		maxIdleConnections,
		getMigrations(),
	); err != nil {
		return nil, err
	}

	return newAuthenticator, nil
}

func (a *Authenticator) Close() {
	a.database.Close()
}
